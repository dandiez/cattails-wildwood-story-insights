"""Write the schemas as dataclasses from inspecting the gameresources files."""
import dataclasses
import os.path
from collections import defaultdict
from typing import Collection

import black

from cws_insights.common import slug_it
from cws_insights.read_files import read_all, ResourceFile, ResourcesRelPath

SCHEMAS_DIR = os.path.join(os.path.dirname(__file__), "schemas")

@dataclasses.dataclass
class ModuleClassNames:
    module_name: str
    class_name: str


@dataclasses.dataclass
class ClassDefinition:
    full_class_code: str
    class_name: str


def class_name_from_path(object_path: ResourcesRelPath) -> str:
    parts = object_path.replace("_", "/").split("/")
    capitalised = [p.capitalize() for p in parts]
    return "".join(capitalised)


def dataclass_types_from_set(the_types: set[type]) -> str:
    return "|".join(sorted([t.__name__ for t in the_types]))


@dataclasses.dataclass
class KeyAttributeMapper:
    special_mapping: dict = dataclasses.field(default_factory=dict)

    def key_to_attribute(self, key: str):
        """Get the python attribute corresponding to a given json key.

        Also keep track of those keys that had to be sluggified to be valid python attributes.
        """
        slugged = slug_it(key)
        if slugged == key:
            return key
        if slugged in self.special_mapping:
            if self.special_mapping[slugged] != key:
                raise ValueError(
                    f"Cannot have two keys '{self.special_mapping[slugged]}' and '{key}' mapping to the same attribute '{slugged}'."
                )
        self.special_mapping[key] = slugged
        return slugged


def get_special_mapping_lines(mappings: KeyAttributeMapper):
    if mappings.special_mapping:
        special_mapping_import = "from typing import ClassVar"
        special_mapping_str = (
            f"__special_mappings: ClassVar[dict] = {mappings.special_mapping}"
        )
    else:
        special_mapping_import = ""
        special_mapping_str = ""
    return special_mapping_import, special_mapping_str


def get_dataclass_attribute_definitions_as_str(
    key_types: dict[str, set[type]], mappings: KeyAttributeMapper
):
    attrs = sorted(
        [
            f"{mappings.key_to_attribute(key)}: {dataclass_types_from_set(types)} = Undefined"
            for key, types in key_types.items()
        ]
    )
    attrs_as_string = "\n    ".join(attrs)
    return attrs_as_string


def get_all_unique_keys_with_their_types(collection: list[ResourceFile]):
    """Go through all resource files in a collection and get all unique keys and their types."""
    key_types = defaultdict(set)
    for f in collection:
        for k, v in f.contents.items():
            key_types[k].add(type(v))
    return key_types


def get_python_module_with_dataclass_as_str(
    collection: list[ResourceFile], collection_rel_path: ResourcesRelPath
) -> ClassDefinition:
    class_name = class_name_from_path(collection_rel_path)
    key_types = get_all_unique_keys_with_their_types(collection)
    mappings = KeyAttributeMapper()
    attrs_as_string = get_dataclass_attribute_definitions_as_str(key_types, mappings)
    special_mapping_import, special_mapping_str = get_special_mapping_lines(mappings)
    dataclass_def = f"""import dataclasses
{special_mapping_import}
from cws_insights.definitions import Undefined

@dataclasses.dataclass
class {class_name}:
    '''Dataset associated with files in 'gameresources/{collection_rel_path}'.'''
    {special_mapping_str}
    {attrs_as_string}
"""
    dataclass_def = black.format_str(dataclass_def, mode=black.FileMode())
    return ClassDefinition(full_class_code=dataclass_def, class_name=class_name)


def write_schema_as_dataclass(
    collection_rel_path: ResourcesRelPath,
    collection: list[ResourceFile],
    output_dir: str,
) -> ModuleClassNames:
    dataclass_code = get_python_module_with_dataclass_as_str(
        collection, collection_rel_path
    )
    module_name = slug_it(collection_rel_path.lower())
    file_path = os.path.join(output_dir, module_name + ".py")
    with open(file_path, "w") as f:
        f.write(dataclass_code.full_class_code)
    return ModuleClassNames(module_name, dataclass_code.class_name)


def clean_schemas_dir(schemas_dir: str):
    """Wipe all py files from the schemas dir and initialise it with an __init__.py."""
    files = os.listdir(schemas_dir)
    for file_name in files:
        if file_name.endswith(".py"):
            os.remove(os.path.join(schemas_dir, file_name))
    with open(os.path.join(schemas_dir, "__init__.py"), "w") as f:
        f.write('"""Autogenerated schemas based on gameresources files."""\n')


def write_index(index: dict[ResourcesRelPath, ModuleClassNames], schemas_dir: str):
    module_as_str = get_index_module_code(index)
    with open(os.path.join(schemas_dir, "_index.py"), "w") as f:
        f.write(module_as_str)


def get_index_module_code(index: dict[ResourcesRelPath, ModuleClassNames]) -> str:
    index: dict[ResourcesRelPath, ModuleClassNames] = {
        k: v for k, v in sorted(index.items(), key=lambda item: item[0])
    }
    imports = "\n".join(
        [
            f"from cws_insights.schemas.{module_class_names.module_name} import {module_class_names.class_name}"
            for module_class_names in index.values()
        ]
    )
    collection_rel_path_to_dataclass_mapping = "\n".join(
        [
            f"    '{rel_path}':{module_and_class_name.class_name},"
            for rel_path, module_and_class_name in index.items()
        ]
    )
    mappings = (
        "COLLECTION_REL_PATH_TO_DATACLASS_MAPPING={\n"
        + collection_rel_path_to_dataclass_mapping
        + "}"
    )
    module_as_str = f"""{imports}
    
{mappings}
    """
    module_as_str = black.format_str(module_as_str, mode=black.FileMode())
    return module_as_str


def main(gameresources_dir: str, extensions_to_consider: Collection[str], schemas_dir: str):
    all_data = read_all(gameresources_dir, file_suffixes=extensions_to_consider)
    clean_schemas_dir(schemas_dir)
    index = dict()
    for collection_rel_path, collection in all_data.items():
        module_class_names = write_schema_as_dataclass(
            collection_rel_path, collection, schemas_dir
        )
        index[collection_rel_path] = module_class_names
    write_index(index, schemas_dir)


if __name__ == "__main__":
    gameresources_dir = r"C:\Program Files (x86)\Steam\steamapps\common\Cattails Wildwood Story\gameresources"
    extensions_to_consider = (".meta", ".lang")
    schemas_dir = SCHEMAS_DIR
    main(gameresources_dir, extensions_to_consider, schemas_dir)
